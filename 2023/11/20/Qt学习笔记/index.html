

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="hhy">
  <meta name="keywords" content="">
  
    <meta name="description" content="目录 1、创建第一个Qt程序 2、命名规范以及快捷键 3、QPushBottom的创建 4、对象树 5、Qt中的坐标系 6、信号和槽 6.1 实现点击按钮关闭窗口 6.2 自定义的信号和槽 6.3 自定义的信号和槽发生重载的解决 6.4 信号连接信号 6.5 Qt4版本信号连接 6.5 Lambda表达式 6.6 信号槽的总结 7、QMainWindow 7.1 菜单栏和工具栏 7.2 状态栏、铆">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt学习笔记">
<meta property="og:url" content="http://example.com/2023/11/20/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Haoyu&#39;s Notes">
<meta property="og:description" content="目录 1、创建第一个Qt程序 2、命名规范以及快捷键 3、QPushBottom的创建 4、对象树 5、Qt中的坐标系 6、信号和槽 6.1 实现点击按钮关闭窗口 6.2 自定义的信号和槽 6.3 自定义的信号和槽发生重载的解决 6.4 信号连接信号 6.5 Qt4版本信号连接 6.5 Lambda表达式 6.6 信号槽的总结 7、QMainWindow 7.1 菜单栏和工具栏 7.2 状态栏、铆">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9e6a1e572f5b43e2a47e600a65ab76a9.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4a89150ea2da448198e805c3c6822571.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8bcf33facc9a4fb4892d00e04c5426c5.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/99021ca875844da2975a459e809f7d52.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/493d66a0b08d49bc9fce17e9892b943c.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d8ae4c24ce504df291579ac2aecd8b46.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a2bdc3ff08814234a33ae64691694ff4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/93d865abe0d64a69ab42221e26809c90.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/db156b981d7d452c98fc318f5ebd4181.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/000a2863ae8f40e6a3125386f8444ac6.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/3c5da778caae497dabf5861847bce9ac.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0b39e92349db4e7481d4e0f1a6883274.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ad0ea8cd5b1e465aa1504df2bb775326.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/c05ec249778e4864adf7014d74cdaa2c.png">
<meta property="article:published_time" content="2023-11-20T12:58:22.000Z">
<meta property="article:modified_time" content="2023-11-21T03:37:47.774Z">
<meta property="article:author" content="hhy">
<meta property="article:tag" content="Qt">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/9e6a1e572f5b43e2a47e600a65ab76a9.png">
  
  
  
  <title>Qt学习笔记 - Haoyu&#39;s Notes</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"ad1a5e5f88443bec4eac294a460a655e","google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?ad1a5e5f88443bec4eac294a460a655e";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Haoyu&#39;s Notes</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Qt学习笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-20 20:58" pubdate>
          2023年11月20日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          27k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          228 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Qt学习笔记</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年11月21日 中午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p><strong>目录</strong></p>
<p><a href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAQt%E7%A8%8B%E5%BA%8F">1、创建第一个Qt程序</a></p>
<p><a href="#2%E3%80%81%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E4%BB%A5%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE">2、命名规范以及快捷键</a></p>
<p><a href="#3%E3%80%81QPushBottom%E7%9A%84%E5%88%9B%E5%BB%BA">3、QPushBottom的创建</a></p>
<p><a href="#%C2%A04%E3%80%81%E5%AF%B9%E8%B1%A1%E6%A0%91">4、对象树</a></p>
<p><a href="#5%E3%80%81Qt%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB">5、Qt中的坐标系</a></p>
<p><a href="#6%E3%80%81%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD">6、信号和槽</a></p>
<p><a href="#6.1%20%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E5%85%B3%E9%97%AD%E7%AA%97%E5%8F%A3">6.1 实现点击按钮关闭窗口</a></p>
<p><a href="#%C2%A06.2%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD">6.2 自定义的信号和槽</a></p>
<p><a href="#6.3%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E5%8F%91%E7%94%9F%E9%87%8D%E8%BD%BD%E7%9A%84%E8%A7%A3%E5%86%B3">6.3 自定义的信号和槽发生重载的解决</a></p>
<p><a href="#%C2%A06.4%20%E4%BF%A1%E5%8F%B7%E8%BF%9E%E6%8E%A5%E4%BF%A1%E5%8F%B7">6.4 信号连接信号</a></p>
<p><a href="#6.5%20Qt4%E7%89%88%E6%9C%AC%E4%BF%A1%E5%8F%B7%E8%BF%9E%E6%8E%A5">6.5 Qt4版本信号连接</a></p>
<p><a href="#%C2%A06.5%20Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">6.5 Lambda表达式</a></p>
<p><a href="#%C2%A06.6%20%E4%BF%A1%E5%8F%B7%E6%A7%BD%E7%9A%84%E6%80%BB%E7%BB%93">6.6 信号槽的总结</a></p>
<p><a href="#7%E3%80%81QMainWindow">7、QMainWindow</a></p>
<p><a href="#7.1%C2%A0%E8%8F%9C%E5%8D%95%E6%A0%8F%E5%92%8C%E5%B7%A5%E5%85%B7%E6%A0%8F">7.1 菜单栏和工具栏</a></p>
<p><a href="#7.2%20%E7%8A%B6%E6%80%81%E6%A0%8F%E3%80%81%E9%93%86%E6%8E%A5%E9%83%A8%E4%BB%B6%E3%80%81%E6%A0%B8%E5%BF%83%E9%83%A8%E4%BB%B6%C2%A0">7.2 状态栏、铆接部件、核心部件</a> </p>
<p><a href="#8%E3%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E6%B7%BB%E5%8A%A0%C2%A0">8、资源文件的添加</a> </p>
<p><a href="#9%E3%80%81%E6%A8%A1%E6%80%81%E5%92%8C%E9%9D%9E%E6%A8%A1%E6%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%88%9B%E5%BB%BA">9、模态和非模态对话框创建</a></p>
<p><a href="#10%E3%80%81%E6%B6%88%E6%81%AF%E5%AF%B9%E8%AF%9D%E6%A1%86">10、消息对话框</a></p>
<p><a href="#11%E3%80%81%E5%85%B6%E4%BB%96%E5%AF%B9%E8%AF%9D%E6%A1%86">11、其他对话框</a></p>
<p><a href="#12%E3%80%81%E7%99%BB%E9%99%86%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80">12、登陆窗口布局</a></p>
<p><a href="#13%E3%80%81%E6%8E%A7%E4%BB%B6">13、控件</a></p>
<p><a href="#13.1%20%E6%8C%89%E9%92%AE%E7%BB%84">13.1 按钮组</a></p>
<p><a href="#%C2%A013.2%20QListWidget%E6%8E%A7%E4%BB%B6">13.2 QListWidget控件</a></p>
<p><a href="#%C2%A013.3%20QTreeWidget%E6%8E%A7%E4%BB%B6">13.3 QTreeWidget控件</a></p>
<p><a href="#%C2%A013.4%20QTableWidget%E6%8E%A7%E4%BB%B6">13.4 QTableWidget控件</a></p>
<p><a href="#%C2%A013.5%20%E5%85%B6%E4%BB%96%E6%8E%A7%E4%BB%B6%E4%BB%8B%E7%BB%8D">13.5 其他控件介绍</a></p>
<p><a href="#14%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6">14、自定义控件</a></p>
<p><a href="#%C2%A015%E3%80%81Qt%E7%9A%84%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6">15、Qt的鼠标事件</a></p>
<p><a href="#16%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8">16、定时器</a></p>
<p><a href="#17%E3%80%81event%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%99%A8%E5%92%8C%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8%C2%A0">17、event 事件分发器和事件过滤器</a> </p>
<p><a href="#%E2%80%8B%E7%BC%96%E8%BE%91">​编辑</a></p>
<p><a href="#18%E3%80%81QPainter">18、QPainter</a></p>
<p><a href="#18.1%20%E7%BB%98%E5%9B%BE%E4%BA%8B%E4%BB%B6%C2%A0">18.1 绘图事件</a> </p>
<p><a href="#%C2%A018.2%20%E7%BB%98%E5%9B%BE%E9%AB%98%E7%BA%A7%E8%AE%BE%E7%BD%AE">18.2 绘图高级设置</a></p>
<p><a href="#%C2%A018.3%20%E6%89%8B%E5%8A%A8%E8%B0%83%E7%94%A8%E7%BB%98%E5%9B%BE%E4%BA%8B%E4%BB%B6">18.3 手动调用绘图事件</a></p>
<p><a href="#18.4%20%E7%BB%98%E5%9B%BE%E8%AE%BE%E5%A4%87%C2%A0">18.4 绘图设备</a> </p>
<p><a href="#19%E3%80%81QFile%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C">19、QFile文件读写操作</a></p>
<p><a href="#%E6%96%87%E4%BB%B6QFile%E5%92%8C%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E8%AF%BB%E5%86%99QFileInfo">文件QFile和文件信息读写QFileInfo</a></p>
<p><a href="#20%E3%80%81%E7%BF%BB%E9%87%91%E5%B8%81%E9%A1%B9%E7%9B%AE%C2%A0">20、翻金币项目</a> </p>
<p> <a href="#%C2%A0***%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">***问题总结</a></p>
<hr>
<h2 id="1、创建第一个Qt程序"><a href="#1、创建第一个Qt程序" class="headerlink" title="1、创建第一个Qt程序"></a>1、创建第一个Qt程序</h2><blockquote>
<p>Create Project-&gt;Qt Widgets Application(创建一个Qt应用，包含一个基于qt设计师的主窗体)</p>
<p>-&gt;Location(不能有空格和中文，可以有下划线)，**路径选择不能有中文(重要！！！)**-&gt;Build System(<strong>选择qmake</strong>，ps：一般的Qt工程你就直接使用qmake就可以了，cmake的强大功能一般人是用不到的 &#x2F;&#x2F;参考的另一篇博客)-&gt;Details(QWidget是QDialog和QMainWindow的父类，Qwidget是空窗口，QMainWindow多了工具栏，QDialog是对话框)，选择QWidget作为基类，取消Generate form使用代码编写。-&gt;Kits(选择套件)-&gt;Summary(finish)团队开发时，添加到版本控制系统（svn，vss，git）</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/9e6a1e572f5b43e2a47e600a65ab76a9.png" srcset="/img/loading.gif" lazyload></p>
<p> main函数代码</p>
<pre><code class="hljs">#include &quot;mywidget.h&quot;

#include &lt;QApplication&gt;// 包含一个应用程序类的头文件

// main程序入口 argc命令行变量的数量 argv命令行变量的数组
int main(int argc, char *argv[])
&#123;
    QApplication a(argc, argv);// a应用程序对象，在qt中，有且仅有一个
    MyWidget w;// 创建窗口对象，MyWidget的父类-&gt;QWidget
    w.show();// 窗口对象 默认不会显示，必须调用show方法显示
    return a.exec();//让应用程序对象a进入消息循环机制，等待用户点叉叉，使得窗口不会一闪而过，使代码阻塞到这一行
&#125;
</code></pre>
<h2 id="2、命名规范以及快捷键"><a href="#2、命名规范以及快捷键" class="headerlink" title="2、命名规范以及快捷键"></a>2、命名规范以及快捷键</h2><p><strong>.pro文件不要添加任何东西，除非你知道写的是什么</strong>。.pro文件就是工程文件，它是qmake自动生</p>
<p>成的用于生产makefile的配置文件。</p>
<pre><code class="hljs">QT       += core gui //Qt包含的模块

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets//大于4版本以上，包含widget模块

CONFIG += c++17

# You can make your code fail to compile if it uses deprecated APIs.
# In order to do so, uncomment the following line.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0
//源文件
SOURCES += \
    main.cpp \
    mywidget.cpp
//头文件 自动生成的
HEADERS += \
    mywidget.h
</code></pre>
<p>Qt基本模块</p>
<p><img src="https://img-blog.csdnimg.cn/4a89150ea2da448198e805c3c6822571.png" srcset="/img/loading.gif" lazyload></p>
<p> mywidget.h</p>
<pre><code class="hljs">#ifndef MYWIDGET_H
#define MYWIDGET_H

#include &lt;QWidget&gt;//窗口类头文件 QWidget

class MyWidget : public QWidget
&#123;
    Q_OBJECT // Q_OBJECT宏，允许类中使用信号和槽的机制

public:
    MyWidget(QWidget *parent = nullptr); // 有参构造函数
    ~MyWidget();
&#125;;
#endif // MYWIDGET_H
</code></pre>
<p>mywidget.cpp </p>
<pre><code class="hljs">#include &quot;mywidget.h&quot;

// 命名规范
// 类名 首字母大写，单词和单词之间首字母大写
// 函数名 变量名称 首字母小写，单词和单词之间首字母大写

// 快捷键
// 注释 ctrl + /
// 运行 ctrl + r
// 编译 ctrl + b
// 字体缩放 ctrl + 鼠标滚轮
// 查找 ctrl + f
// 整行移动 ctrl + shift + ⬆或者⬇
// 帮助文档 F1
// 自动对齐 ctrl + i
// 同名之间的.h和.cpp切换 F4

// 帮助文档，左侧的帮助；在Qt5.16\mingw49_32\bin的Qt助手

MyWidget::MyWidget(QWidget *parent)
    : QWidget(parent)// 初始化列表
&#123;
&#125;

MyWidget::~MyWidget()
&#123;
&#125;
</code></pre>
<p>​    </p>
<h2 id="3、QPushBottom的创建"><a href="#3、QPushBottom的创建" class="headerlink" title="3、QPushBottom的创建"></a>3、QPushBottom的创建</h2><p> 构造函数里创建</p>
<pre><code class="hljs">#include &quot;mywidget.h&quot;
#include &lt;QPushButton&gt;

MyWidget::MyWidget(QWidget *parent)
    : QWidget(parent)// 初始化列表
&#123;
    // 创建一个按钮
    QPushButton * btn = new QPushButton;
    // btn-&gt;show();// show以顶层方式弹出窗口控件
    // 让btn对象 依赖在 MyWdget窗口中
    btn-&gt;setParent(this);

    // 显示文本
    btn-&gt;setText(&quot;first button&quot;);

    // 创建第二个按钮 按照控件的大小创建窗口
    QPushButton * btn2 = new QPushButton(&quot;second button&quot;,this);
    // 重置窗口大小 长x宽
    resize(600,400);
    
    // 移动btn2按钮,设置坐标
    btn2-&gt;move(100,100);
    
    // 设置固定窗口大小,用户不能改变串窗口大小
    setFixedSize(600,400);
    
    // 设置窗口标题
    setWindowTitle(&quot;第一个窗口&quot;);

&#125;

MyWidget::~MyWidget()
&#123;
&#125;
</code></pre>
<p>​    </p>
<h2 id="4、对象树"><a href="#4、对象树" class="headerlink" title="4、对象树"></a>4、对象树</h2><p>父类先构造，子类先析构</p>
<p>在Qt中创建对象的时候会提供一个Parent对象指针。</p>
<p>QObject是以对象树的形式组织起来的。</p>
<blockquote>
<p>当你创建一个QObject对象时候，会看到QObject的构造函数接收一个QObject指针作为参数，这个参数就是Parent，也就是父对象指针。</p>
<p>这相当于，在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父类对象的children()列表。</p>
<p>当父类对象析构的时候，这个列表中的所有对象也会被析构（<strong>注意：这里的父对象并不是继承意义的父类</strong>）</p>
<p>QWdget是能够在屏幕上显示的一切组件的父类。<br>QWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时侯，应用程序将共刑除，那么，我们希望属于这个对话框的按钮、图标等应该一起被迸除。事实就是如此，因为这些都是对话框的子组件。</p>
</blockquote>
<p> MyPushButton类的创建</p>
<pre><code class="hljs">#ifndef MYPUSHBUTTON_H
#define MYPUSHBUTTON_H

#include &lt;QPushButton&gt;//继承QPushButton，没有这个选择就先选择继承它的父亲

class MyPushButton : public QPushButton
&#123;
    Q_OBJECT
public:
    explicit MyPushButton(QWidget *parent = nullptr);

    ~MyPushButton();

signals:

&#125;;

#endif // MYPUSHBUTTON_H


#include &quot;mypushbutton.h&quot;
#include &lt;QDebug&gt;//打印输出

MyPushButton::MyPushButton(QWidget *parent)
    : QPushButton(parent)//换父亲
&#123;
    qDebug()&lt;&lt;&quot;我的按钮类构造调用&quot;;
&#125;

MyPushButton::~MyPushButton()
&#123;
    qDebug()&lt;&lt;&quot;我的按钮类析构调用&quot;;
&#125;
</code></pre>
<p>打印先打印的是儿子的析构，但是是后面释放。 </p>
<pre><code class="hljs">#include &quot;mywidget.h&quot;
#include &lt;QPushButton&gt;
#include &lt;mypushbutton.h&gt;
#include &lt;QDebug&gt;//打印输出
MyWidget::MyWidget(QWidget *parent)
    : QWidget(parent)// 初始化列表
&#123;

    // 创建一个自己的按钮对象
    MyPushButton *mybtn = new MyPushButton;
    mybtn-&gt;setText(&quot;我自己的按钮&quot;);
    mybtn-&gt;move(200,0);
    mybtn-&gt;setParent(this);
    qDebug()&lt;&lt;&quot;MyWidget构造&quot;;
&#125;

MyWidget::~MyWidget()
&#123;
    qDebug()&lt;&lt;&quot;MyWidget析构&quot;;
&#125;
</code></pre>
<p>​<br>​    </p>
<blockquote>
<p><strong>总结：</strong>当创建的对象在堆区时候，如果指定的父亲是QObject派生下来的类或者QObject子类派生下来的类，**可以不用管理释放的操作(就是不用deletex)**，将对象会放入到对象树中。一定程度上简化了内存回收机制</p>
</blockquote>
<h2 id="5、Qt中的坐标系"><a href="#5、Qt中的坐标系" class="headerlink" title="5、Qt中的坐标系"></a>5、Qt中的坐标系</h2><p>左上角为(0,0)，x向右增大，y向下增大</p>
<h2 id="6、信号和槽"><a href="#6、信号和槽" class="headerlink" title="6、信号和槽"></a>6、信号和槽</h2><h3 id="6-1-实现点击按钮关闭窗口"><a href="#6-1-实现点击按钮关闭窗口" class="headerlink" title="6.1 实现点击按钮关闭窗口"></a>6.1 实现点击按钮关闭窗口</h3><blockquote>
<p><img src="https://img-blog.csdnimg.cn/8bcf33facc9a4fb4892d00e04c5426c5.png" srcset="/img/loading.gif" lazyload></p>
<p>connect( 信号的发送者，发送的具体信号，信号的接受者，信号的处理（槽）)</p>
<p>信号槽的优点：松散耦合，信号发送端和接受端本身是没有关联的，通过connect连接将两端耦合在一起。 </p>
</blockquote>
<pre><code class="hljs">#include &quot;mywidget.h&quot;
#include &lt;QPushButton&gt;
#include &lt;mypushbutton.h&gt;
#include &lt;QDebug&gt;//打印输出
MyWidget::MyWidget(QWidget *parent)
    : QWidget(parent)// 初始化列表
&#123;

    // 创建一个自己的按钮对象
    MyPushButton *mybtn = new MyPushButton;
    mybtn-&gt;setText(&quot;我自己的按钮&quot;);
    mybtn-&gt;move(200,0);
    mybtn-&gt;setParent(this);

    // 点击我的按钮，关掉窗口
    // 参数1：信号的发送者，参数2：发送的具体信号(点击)函数的地址;参数3：信号的接受者this窗口，参数4：信号的处理（槽）函数地址
    connect(mybtn,&amp;MyPushButton::clicked,this,&amp;MyWidget::close);
    //connect(mybtn,&amp;QPushButton::clicked,this,&amp;QWidget::close);// 用父类的也可以
&#125;

MyWidget::~MyWidget()
&#123;
&#125;
</code></pre>
<p>​    </p>
<h3 id="6-2-自定义的信号和槽"><a href="#6-2-自定义的信号和槽" class="headerlink" title="6.2 自定义的信号和槽"></a>6.2 自定义的信号和槽</h3><blockquote>
<p>自定义信号：写到signals下；返回值是void，只需要声明，不需要实现；可以有参数，可以重载。</p>
<p>自定义槽：早期Qt槽函数必须写在public slot下，高级版本可以写道public或者全局下；返回值是void，需要声明，也需要实现；可以有参数，可以重载。</p>
<p>触发自定义信号：emit</p>
</blockquote>
<pre><code class="hljs">#include &quot;widget.h&quot;

// Teacher 类 老师类
// Student 类 学生类
// 下课后，老师会触发一个信号，饿了，学生响应信号，请客吃饭

Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;
    // 创建老师和学生对象，并且指定父亲，就不用释放
    this-&gt;zt = new Teacher(this);
    this-&gt;st = new Student(this);

    connect(zt,&amp;Teacher::Hungry,st,&amp;Student::treat);

    // 调用下课,触发老师饿了，随后学生响应
    classisover();
&#125;

Widget::~Widget()
&#123;
&#125;

void Widget::classisover()
&#123;
    // 下课函数 调用后触发老师饿了信号
    emit zt-&gt;Hungry();
&#125;
</code></pre>
<h3 id="6-3-自定义的信号和槽发生重载的解决"><a href="#6-3-自定义的信号和槽发生重载的解决" class="headerlink" title="6.3 自定义的信号和槽发生重载的解决"></a>6.3 自定义的信号和槽发生重载的解决</h3><blockquote>
<p>1.需要利用函数指针明确指向函数的地址，成员函数指针需要加上作用域</p>
<p>2.QString-&gt;char * 先转成QByteArray(.toUtf8())再转char*(),.data的返回值是char *</p>
</blockquote>
<p>Widget代码 </p>
<pre><code class="hljs">#include &quot;widget.h&quot;

// Teacher 类 老师类
// Student 类 学生类
// 下课后，老师会触发一个信号，饿了，学生响应信号，请客吃饭

Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;
    // 创建老师和学生对象，并且指定父亲，就不用释放
    this-&gt;zt = new Teacher(this);
    this-&gt;st = new Student(this);

    //connect(zt,&amp;Teacher::Hungry,st,&amp;Student::treat);

    // 调用下课,触发老师饿了，随后学生响应
    //classisover();
    // 函数指针-&gt;函数地址,&amp;+函数名
    void(Teacher::*teacherSignal)(QString) = &amp;Teacher::Hungry;// 成员函数的函数指针
    void(Student::*studentSlot)(QString) = &amp;Student::treat;
    // 当出现重载的时候，需要出现设置信号和槽的函数地址
    connect(zt,teacherSignal,st,studentSlot);//重载出现二义性

    classisover();
&#125;

Widget::~Widget()
&#123;
&#125;

void Widget::classisover()
&#123;
    // 下课函数 调用后触发老师饿了信号,两个信号
    emit zt-&gt;Hungry();
    emit zt-&gt;Hungry(&quot;宫保鸡丁&quot;);
&#125;
</code></pre>
<p> 槽函数重载</p>
<pre><code class="hljs">#include &quot;student.h&quot;
#include &lt;QDebug&gt;
Student::Student(QObject *parent)
    : QObject&#123;parent&#125;
&#123;

&#125;

void Student::treat()
&#123;
    qDebug()&lt;&lt;&quot;请老师吃饭&quot;;
&#125;
void Student::treat(QString foodname)// 重载treat
&#123;
    //打印QString类型有引号，要转成char*就没有引号
    //qDebug()&lt;&lt;&quot;请老师吃饭,老师要吃：&quot;&lt;&lt;foodname;
    // QString-&gt;char * 先转成QByteArray(.toUtf8())再转char*(),data的返回值是char *
    qDebug()&lt;&lt;&quot;请老师吃饭,老师要吃：&quot;&lt;&lt;foodname.toUtf8().data();
&#125;
</code></pre>
<p> 信号重载</p>
<pre><code class="hljs">void Hungry();
void Hungry(QString foodname);
</code></pre>
<h3 id="6-4-信号连接信号"><a href="#6-4-信号连接信号" class="headerlink" title="6.4 信号连接信号"></a>6.4 信号连接信号</h3><blockquote>
<p>connect(btn,&amp;QPushButton::clicked,zt,teacherSignal);teacherSignal要换成无参形式，否则参数不匹配；</p>
</blockquote>
<pre><code class="hljs">#include &quot;widget.h&quot;
#include &lt;QPushButton&gt;
// Teacher 类 老师类
// Student 类 学生类
// 下课后，老师会触发一个信号，饿了，学生响应信号，请客吃饭

Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;
    // 创建老师和学生对象，并且指定父亲，就不用释放
    this-&gt;zt = new Teacher(this);
    this-&gt;st = new Student(this);

    //点击一个按钮，再下课，再触发老师饿了
    QPushButton *btn = new QPushButton(&quot;下课&quot;,this);
    this-&gt;resize(600,400); // 重置窗口大小
    connect(btn,&amp;QPushButton::clicked,this,&amp;Widget::classisover);

    //无参信号和槽连接
    void(Teacher::*teacherSignal)(void) = &amp;Teacher::Hungry;// 成员函数的函数指针
    void(Student::*studentSlot)(void) = &amp;Student::treat;
    connect(zt,teacherSignal,st,studentSlot);

    // 信号连接信号 之间跳过下课，按钮直接使老师饿了
    connect(btn,&amp;QPushButton::clicked,zt,teacherSignal);
</code></pre>
<p>​<br>​        &#x2F;&#x2F; 断开信号<br>​        &#x2F;&#x2F;disconnect(zt,teacherSignal,st,studentSlot);<br>​    }<br>​<br>​    Widget::~Widget()<br>​    {<br>​    }<br>​<br>​    void Widget::classisover()<br>​    {<br>​        &#x2F;&#x2F; 下课函数 调用后触发老师饿了信号,两个信号<br>​        emit zt-&gt;Hungry();<br>​        emit zt-&gt;Hungry(“宫保鸡丁”);<br>​    }</p>
<h3 id="6-5-Qt4版本信号连接"><a href="#6-5-Qt4版本信号连接" class="headerlink" title="6.5 Qt4版本信号连接"></a>6.5 Qt4版本信号连接</h3><blockquote>
<p>1.信号可以连接信号；</p>
<p>2.一个信号可以连接多个槽函数；</p>
<p>3.多个信号可以连接同一个槽函数；</p>
<p><strong>4.信号和槽函数的参数，必须一一对应；</strong></p>
<p>5.<strong>信号的参数个数可以多于槽函数的参数个数，但是类型要一一对应</strong>；</p>
<p>clicked的参数是bool类型，teacherSignal如果是QString参数就不是一一对应，如果是void参数就是信号的参数比槽函数的参数多，所以不会报错。</p>
<p>6.Qt4：connect(zt,SIGNAL(hungry()),st,SLOT(treat(QString));参数直观，但是不做类型检测，不推荐。</p>
</blockquote>
<h3 id="6-5-Lambda表达式"><a href="#6-5-Lambda表达式" class="headerlink" title="6.5 Lambda表达式"></a>6.5 Lambda表达式</h3><blockquote>
<p>C++11中的Lambda表达式用于定义并创建匿名函数对象，以简化编程工作。</p>
<p>表达式：[函数对象参数](操作符重载函数参数)mutable-&gt;返回值(函数体)</p>
<p><img src="https://img-blog.csdnimg.cn/99021ca875844da2975a459e809f7d52.png" srcset="/img/loading.gif" lazyload></p>
<p> ① “&#x3D;”为值传递，“&amp;”为地址传递，a为只对a可见；</p>
<p> ② mutable关键字，用于修饰值传递的变量，修改拷贝而不是本体；</p>
<p> ③ int ret &#x3D; [ ]( )-&gt;<strong>int</strong> {return 100;}();使得ret&#x3D;100；</p>
</blockquote>
<pre><code class="hljs">Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;

    QPushButton *btn = new QPushButton;
    this-&gt;resize(600,400); // 重置窗口大小
    btn-&gt;setText(&quot;close&quot;);
    btn-&gt;setParent(this);//把按钮安到窗口上
    //利用lambda表达式实现关闭按钮
    connect(btn,&amp;QPushButton::clicked,this,[=]()&#123;
        this-&gt;close();
        btn-&gt;setText(&quot;aaa&quot;);
    &#125;);

&#125;
</code></pre>
<h3 id="6-6-信号槽的总结"><a href="#6-6-信号槽的总结" class="headerlink" title="6.6 信号槽的总结"></a>6.6 信号槽的总结</h3><blockquote>
<p>  任务：设计一个窗口，两个按钮，点击open打开另一个窗口，点击close关闭窗口。</p>
</blockquote>
<pre><code class="hljs">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;
#include &lt;QPushButton&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    QPushButton *btn = new QPushButton;
    btn-&gt;setText(&quot;open&quot;);
    btn-&gt;setParent(this);
    resize(600,400);

    QPushButton *btn2 = new QPushButton;
    btn2-&gt;setText(&quot;close&quot;);
    btn2-&gt;setParent(this);
    btn2-&gt;move(200,200);

    QWidget *w2=new QWidget;

    connect(btn,&amp;QPushButton::clicked,w2,&amp;QWidget::show);

    connect(btn2,&amp;QPushButton::clicked,w2,&amp;QWidget::close);

&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;
</code></pre>
<p>​    </p>
<blockquote>
<p>    任务：设计一个窗口，一个按钮，点击open打开另一个窗口，open变成close，再点击close关闭窗口，close变成open。</p>
</blockquote>
<pre><code class="hljs">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;
#include &lt;QPushButton&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    QPushButton *btn = new QPushButton;
    btn-&gt;setText(&quot;open&quot;);
    btn-&gt;setParent(this);
    resize(600,400);

    QWidget *w1 = new QWidget;

    connect(btn,&amp;QPushButton::clicked,w1,[=]()&#123;
        if(btn-&gt;text()==&quot;open&quot;)
        &#123;
            btn-&gt;setText(&quot;close&quot;);
            w1-&gt;show();
        &#125;
        if(btn-&gt;text()==&quot;close&quot;)
        &#123;
            btn-&gt;setText(&quot;open&quot;);
            w1-&gt;close();
        &#125;
    &#125;);
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;
</code></pre>
<p>​    </p>
<h2 id="7、QMainWindow"><a href="#7、QMainWindow" class="headerlink" title="7、QMainWindow"></a>7、QMainWindow</h2><h3 id="7-1-菜单栏和工具栏"><a href="#7-1-菜单栏和工具栏" class="headerlink" title="7.1 菜单栏和工具栏"></a>7.1 菜单栏和工具栏</h3><blockquote>
<p>1.菜单栏最多只有一个，工具栏可以有多个</p>
<p>2.QMenu，QToolBar</p>
</blockquote>
<pre><code class="hljs">#include &quot;mainwindow.h&quot;
#include &lt;QMenuBar&gt;
#include &lt;QToolBar&gt;
#include &lt;QPushButton&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
&#123;
    // 重置窗口大小
    resize(600,400);

    // 菜单栏的创建 最多只有一个
    QMenuBar *bar = menuBar();// 本身在对象树
    setMenuBar(bar); // 将菜单栏放入窗口中
    QMenu *fileMenu = bar-&gt;addMenu(&quot;文件&quot;); // 创建菜单
    QMenu *editMenu = bar-&gt;addMenu(&quot;编辑&quot;);
    QAction * newAction = fileMenu-&gt;addAction(&quot;新建&quot;);// 创建菜单项
    // 添加分割线
    fileMenu-&gt;addSeparator();

    QAction * newAction1 = fileMenu-&gt;addAction(&quot;打开&quot;);
    editMenu-&gt;addAction(&quot;复制&quot;);

    // 工具栏的创建 可以有多个
    QToolBar *toolBar = new QToolBar(this);
    addToolBar(Qt::LeftToolBarArea,toolBar);//默认在左边
    // 只允许左右停靠
    toolBar-&gt;setAllowedAreas(Qt::LeftToolBarArea | Qt::RightToolBarArea);
    // 设置浮动
    toolBar-&gt;setFloatable(false);
    // 设置移动,bool值设置是否可以移动,相当于总开关
    toolBar-&gt;setMovable(false);
    // 设置内容
    toolBar-&gt;addAction(newAction);
    toolBar-&gt;addSeparator();
    toolBar-&gt;addAction(newAction1);
    // 工具栏添加控件
    QPushButton* btn = new QPushButton(&quot;aa&quot;,this);
    toolBar-&gt;addWidget(btn);

&#125;

MainWindow::~MainWindow()
&#123;
&#125;
</code></pre>
<h3 id="7-2-状态栏、铆接部件、核心部件"><a href="#7-2-状态栏、铆接部件、核心部件" class="headerlink" title="7.2 状态栏、铆接部件、核心部件"></a>7.2 状态栏、铆接部件、核心部件</h3><blockquote>
<p>  1.QStatusBar，QDockWidget(浮动窗口)，QTextEdit;</p>
<p> <img src="https://img-blog.csdnimg.cn/493d66a0b08d49bc9fce17e9892b943c.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<pre><code class="hljs">    // 状态栏
    QStatusBar* stBar = statusBar();
    setStatusBar(stBar);//设置到窗口中
    //放标签控件
    QLabel *label = new QLabel(&quot;提示信息&quot;,this);
    stBar-&gt;addWidget(label);

    QLabel *label2 = new QLabel(&quot;右侧提示信息&quot;,this);
    stBar-&gt;addPermanentWidget(label2);

    // 铆接部件（浮动窗口）可以有多个
    QDockWidget *dockWidget = new QDockWidget(&quot;浮动&quot;,this);
    addDockWidget(Qt::BottomDockWidgetArea,dockWidget);
    // 只允许上下
    dockWidget-&gt;setAllowedAreas(Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea);;

    //设置中心部件,只能一个
    QTextEdit *edit = new QTextEdit(this);
    setCentralWidget(edit);
</code></pre>
<h2 id="8、资源文件的添加"><a href="#8、资源文件的添加" class="headerlink" title="8、资源文件的添加 "></a>8、资源文件的添加 </h2><blockquote>
<p>1. 将图片文件拷贝到项目位置；</p>
<p>2. 右键项目-&gt;添加新文件-&gt;Qt-&gt;Qt recourse File-&gt;给资源文件起名</p>
<p>3. rec生成rec.qrc</p>
<p>4. open in editor打开文件</p>
<p>5. 添加前缀 添加文件，编译</p>
<p>6. 使用“:+前缀名+文件名”</p>
<p><img src="https://img-blog.csdnimg.cn/d8ae4c24ce504df291579ac2aecd8b46.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/a2bdc3ff08814234a33ae64691694ff4.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="9、模态和非模态对话框创建"><a href="#9、模态和非模态对话框创建" class="headerlink" title="9、模态和非模态对话框创建"></a>9、模态和非模态对话框创建</h2><blockquote>
<p>1. 模态对话框：不可以对其他窗口进行操作；QDialog dlg(this);dlg.exec();</p>
<p>2. 非模态对话框：可以对其他窗口进行操作；QDialog *dlg2 &#x3D; new QDialog(this);dlg2-&gt;show();</p>
</blockquote>
<pre><code class="hljs">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include &lt;QDialog&gt;
#include &lt;QDebug&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);

    // 点击新建按钮 弹出会话框
    connect(ui-&gt;actionnew,&amp;QAction::triggered,[=]()&#123;
        //对话框 分类
        // 模态对话框（不可以对其他窗口进行操作） 非模态对话框（可以对其他窗口进行操作）
        QDialog dlg(this);
        dlg.resize(200,100);
        dlg.exec();//模态方式创建，阻塞功能

        qDebug()&lt;&lt;&quot;模态对话框弹出了&quot;;

        // 非模态对话框
        QDialog *dlg2 = new QDialog(this);//存在内存泄漏风险，创建堆区
        dlg2-&gt;resize(200,100);
        dlg2-&gt;show();
        dlg2-&gt;setAttribute(Qt::WA_DeleteOnClose);//设置属性，差掉就释放内存
        qDebug()&lt;&lt;&quot;非模态对话框弹出了&quot;;

    &#125;);
&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;
</code></pre>
<h2 id="10、消息对话框"><a href="#10、消息对话框" class="headerlink" title="10、消息对话框"></a>10、消息对话框</h2><blockquote>
<p>QMessageBox 静态成员函数 创建对话框</p>
<p>错误、信息、提问、警告</p>
<p>利用返回值来判断用户的选择</p>
</blockquote>
<pre><code class="hljs">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include &lt;QDialog&gt;
#include &lt;QDebug&gt;
#include &lt;QMessageBox&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);

    // 点击新建按钮 弹出会话框
    connect(ui-&gt;actionnew,&amp;QAction::triggered,[=]()&#123;

        //消息对话框
        //QMessageBox::critical(this,&quot;critical&quot;,&quot;错误&quot;);//错误对话框
        //QMessageBox::information(this,&quot;info&quot;,&quot;信息&quot;);//信息对话框
        //提问对话框
        //参数1：父亲，参数2：标题；参数3：提示内容；参数4：按键类型；参数5：默认关联回车按键
//        QMessageBox::question(this,&quot;ques&quot;,&quot;提问&quot;,QMessageBox::Save|QMessageBox::Cancel,QMessageBox::Cancel);
//        if(QMessageBox::Save ==  QMessageBox::question(this,&quot;ques&quot;,&quot;提问&quot;,QMessageBox::Save|QMessageBox::Cancel,QMessageBox::Cancel))
//        &#123;
//            qDebug()&lt;&lt;&quot;选择了保存&quot;;
//        &#125;
//        else
//        &#123;
//            qDebug()&lt;&lt;&quot;选择了取消&quot;;
//        &#125;

        //警告对话框
        QMessageBox::warning(this,&quot;warning&quot;,&quot;警告&quot;);
    &#125;);
&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;
</code></pre>
<h2 id="11、其他对话框"><a href="#11、其他对话框" class="headerlink" title="11、其他对话框"></a>11、其他对话框</h2><blockquote>
<p>QColorDialog,QFileDialog,QFontDialog</p>
</blockquote>
<pre><code class="hljs"> // 点击新建按钮 弹出会话框
    connect(ui-&gt;actionnew,&amp;QAction::triggered,[=]()&#123;
        //颜色对话框
//        QColor color = QColorDialog::getColor(QColor(255,0,0));
//        qDebug()&lt;&lt;&quot;r = &quot;&lt;&lt;color.red()&lt;&lt;&quot;g = &quot;&lt;&lt;color.green()&lt;&lt;&quot;b = &quot;&lt;&lt;color.blue();

        //文件对话框,参数1：父亲 参数2：名字 参数3：路径 参数4：过滤文件格式
//        QString str = QFileDialog::getOpenFileName(this,&quot;打开文件&quot;,&quot;E:\\BaseFile\\senior\\C++work&quot;,&quot;(*.doc)&quot;);
//        qDebug()&lt;&lt;str;
        bool flag;
        QFont font = QFontDialog::getFont(&amp;flag,QFont(&quot;华文彩云&quot;,32));
        qDebug()&lt;&lt;font.family();
    &#125;);
</code></pre>
<h2 id="12、登陆窗口布局"><a href="#12、登陆窗口布局" class="headerlink" title="12、登陆窗口布局"></a>12、登陆窗口布局</h2><blockquote>
<p>1. 实现登录窗口；</p>
<p>2. 利用布局方式 给窗口进行美化；</p>
<p>3. 选取widget进行布局，水平布局、垂直布局、栅格布局；</p>
<p>4. 给用户名、密码、登录、退出按钮进行布局；</p>
<p>5. 默认窗口和控件之间有9间隙，可以调整 layoutLeftMargin；</p>
<p>6. 利用弹簧进行布局。</p>
<p><img src="https://img-blog.csdnimg.cn/93d865abe0d64a69ab42221e26809c90.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h2 id="13、控件"><a href="#13、控件" class="headerlink" title="13、控件"></a>13、控件</h2><h3 id="13-1-按钮组"><a href="#13-1-按钮组" class="headerlink" title="13.1 按钮组"></a>13.1 按钮组</h3><blockquote>
<p>1. QPushButton 常用按钮；</p>
<p>2. QToolButton 工具按钮；用于显示图片，如图想显示文字，修改风格；ToolButtonStyle；</p>
<p>3. radioButton 单选按钮，设置默认选择ui-&gt;woman-&gt;setChecked(true);</p>
<p>4. checkbox 多选按钮，监听状态，2是选中，1是半选，0是未选。</p>
<p><img src="https://img-blog.csdnimg.cn/db156b981d7d452c98fc318f5ebd4181.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<pre><code class="hljs">Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    //设置单选按钮，男默认选中
    ui-&gt;woman-&gt;setChecked(true);

    //多选按钮，0表示为选择，2表示选中
    connect(ui-&gt;cBox,&amp;QCheckBox::stateChanged,[=](int state)&#123;
               qDebug()&lt;&lt;state;
            &#125;);
&#125;
</code></pre>
<h3 id="13-2-QListWidget控件"><a href="#13-2-QListWidget控件" class="headerlink" title="13.2 QListWidget控件"></a>13.2 QListWidget控件</h3><blockquote>
<p>  QListWidget 列表容器：QListWidgetItem 显示一行内容；</p>
<p> 设置居中方式setTextAlignment（），通过查询assitant帮助文档查询参数。</p>
</blockquote>
<pre><code class="hljs"> // 利用listWidget写诗
//    QListWidgetItem *item = new QListWidgetItem(&quot;一川烟雨，满城风絮，梅子黄时雨&quot;);
//    ui-&gt;listWidget-&gt;addItem(item);//放到listWidget控件里
//    item-&gt;setTextAlignment(Qt::AlignCenter);//水平居中
    //QStringList QList&lt;QString&gt;
    QStringList list;
    list&lt;&lt;&quot;陌上花开&quot;&lt;&lt;&quot;可缓缓归矣&quot;;
    ui-&gt;listWidget-&gt;addItems(list);
</code></pre>
<h3 id="13-3-QTreeWidget控件"><a href="#13-3-QTreeWidget控件" class="headerlink" title="13.3 QTreeWidget控件"></a>13.3 QTreeWidget控件</h3><blockquote>
<p>1. 设置水平头 setHeaderLabels();</p>
<p>2. 创建根节点  QTreeWidgetItem *item1 &#x3D; new QTreeWidgetItem(QStringList()&lt;&lt;”力量”);</p>
<p>3. 添加根节点到树控件  ui-&gt;treeWidget-&gt;addTopLevelItem(item1);</p>
<p>4. 添加子节点 item1-&gt;addChild(l1);</p>
<p><img src="https://img-blog.csdnimg.cn/000a2863ae8f40e6a3125386f8444ac6.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<pre><code class="hljs">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    // treeWidget
    // 设置水平头
    ui-&gt;treeWidget-&gt;setHeaderLabels(QStringList()&lt;&lt;&quot;英雄&quot;&lt;&lt;&quot;英雄介绍&quot;);

    QTreeWidgetItem *item1 = new QTreeWidgetItem(QStringList()&lt;&lt;&quot;力量&quot;);//匿名对象
    QTreeWidgetItem *item2 = new QTreeWidgetItem(QStringList()&lt;&lt;&quot;敏捷&quot;);
    QTreeWidgetItem *item3 = new QTreeWidgetItem(QStringList()&lt;&lt;&quot;智力&quot;);
    // 加载顶层的节点
    ui-&gt;treeWidget-&gt;addTopLevelItem(item1);
    ui-&gt;treeWidget-&gt;addTopLevelItem(item2);
    ui-&gt;treeWidget-&gt;addTopLevelItem(item3);
    //追加子节点
    QStringList heroL1,heroL2,heroL3;
    heroL1&lt;&lt;&quot;200&quot;;
    heroL2&lt;&lt;&quot;100&quot;;
    heroL3&lt;&lt;&quot;130&quot;;
    QTreeWidgetItem *l1 = new QTreeWidgetItem(heroL1);
    QTreeWidgetItem *l2 = new QTreeWidgetItem(heroL2);
    QTreeWidgetItem *l3 = new QTreeWidgetItem(heroL3);
    item1-&gt;addChild(l1);
    item2-&gt;addChild(l2);
    item3-&gt;addChild(l3);
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;
</code></pre>
<h3 id="13-4-QTableWidget控件"><a href="#13-4-QTableWidget控件" class="headerlink" title="13.4 QTableWidget控件"></a>13.4 QTableWidget控件</h3><blockquote>
<p><img src="https://img-blog.csdnimg.cn/3c5da778caae497dabf5861847bce9ac.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<pre><code class="hljs">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    // TableWidget控件
    // 设置列数
    ui-&gt;tableWidget-&gt;setColumnCount(3);
    // 设置水平表头
    ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;&quot;姓名&quot;&lt;&lt;&quot;性别&quot;&lt;&lt;&quot;年龄&quot;);
    // 设置行数
    ui-&gt;tableWidget-&gt;setRowCount(5);
    // 设置正文
    //ui-&gt;tableWidget-&gt;setItem(0,0,new QTableWidgetItem(&quot;亚瑟&quot;));
    QStringList namelist;
    namelist&lt;&lt;&quot;亚瑟&quot;&lt;&lt;&quot;赵云&quot;&lt;&lt;&quot;王昭君&quot;&lt;&lt;&quot;关羽&quot;&lt;&lt;&quot;花木兰&quot;;
    QList&lt;QString&gt; sexList;
    sexList&lt;&lt;&quot;男&quot;&lt;&lt;&quot;男&quot;&lt;&lt;&quot;女&quot;&lt;&lt;&quot;男&quot;&lt;&lt;&quot;女&quot;;
    for(int i = 0; i &lt; 5; i++)
    &#123;
        int col = 0;
        ui-&gt;tableWidget-&gt;setItem(i,col++,new QTableWidgetItem(namelist[i]));
        ui-&gt;tableWidget-&gt;setItem(i,col++,new QTableWidgetItem(sexList.at(i)));//at越界抛异常
        //int 转QString
        ui-&gt;tableWidget-&gt;setItem(i,col++,new QTableWidgetItem(QString::number(i+18)));
    &#125;

&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;
</code></pre>
<h3 id="13-5-其他控件介绍"><a href="#13-5-其他控件介绍" class="headerlink" title="13.5 其他控件介绍"></a>13.5 其他控件介绍</h3><blockquote>
<p>1. stackedWidget控件</p>
<p>2. 下拉框控件comboBox</p>
<p>3. QLabel显示图片和gif </p>
</blockquote>
<pre><code class="hljs">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;
#include &lt;QMovie&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    // 栈控件使用
    // 欢迎按钮
    // 设置默认页面
    ui-&gt;stackedWidget-&gt;setCurrentIndex(0);

    connect(ui-&gt;btn_welcome,&amp;QPushButton::clicked,[=]()&#123;
        ui-&gt;stackedWidget-&gt;setCurrentIndex(0);
    &#125;);
    // 编辑按钮
    connect(ui-&gt;btn_edit,&amp;QPushButton::clicked,[=]()&#123;
        ui-&gt;stackedWidget-&gt;setCurrentIndex(1);
    &#125;);
    // 项目按钮
    connect(ui-&gt;btn_project,&amp;QPushButton::clicked,[=]()&#123;
        ui-&gt;stackedWidget-&gt;setCurrentIndex(2);
    &#125;);
    // 下拉框
    ui-&gt;comboBox-&gt;addItem(&quot;奔驰&quot;);
    ui-&gt;comboBox-&gt;addItem(&quot;宝马&quot;);
    ui-&gt;comboBox-&gt;addItem(&quot;自行车&quot;);

    connect(ui-&gt;btn_bike,&amp;QPushButton::clicked,[=]()&#123;
        //ui-&gt;comboBox-&gt;setCurrentIndex(2);
        ui-&gt;comboBox-&gt;setCurrentText(&quot;自行车&quot;);
    &#125;);
    // 利用QLabel显示图片和gif动态图片
    ui-&gt;lb1-&gt;setPixmap(QPixmap(&quot;:/Image/1.jpg&quot;));
    QMovie *movie = new QMovie(&quot;:/Image/m.gif&quot;);
    ui-&gt;lb1-&gt;setMovie(movie);//嵌入到lbl
    movie-&gt;start();//动起来
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;
</code></pre>
<h2 id="14、自定义控件"><a href="#14、自定义控件" class="headerlink" title="14、自定义控件"></a>14、自定义控件</h2><blockquote>
<p>1、添加新文件，Qt-&gt;设计师界面类（.cpp .h .ui）</p>
<p>2、.ui中设计 QSpinBox和QSlider两个控件</p>
<p>3、Widget中使用自定义控件，拖拽一个Widget，点击提升为，点击添加，点击提升，将.ui变成一个smallWidget类</p>
<p>4、在smallWidget.cpp实现功能，改变数字，滑动条跟着移动，信号槽监听</p>
<p>5、提供两个按钮，对ui的smallWidget实例对象进行操作</p>
</blockquote>
<pre><code class="hljs">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;
#include &lt;QDebug&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    // 点击获取控件当前值
    connect(ui-&gt;btn_set,&amp;QPushButton::clicked,[=]()&#123;
        qDebug()&lt;&lt;ui-&gt;widget-&gt;getNum();
    &#125;);
    connect(ui-&gt;btn_half,&amp;QPushButton::clicked,[=]()&#123;
       ui-&gt;widget-&gt;setNum(50);
    &#125;);
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;
</code></pre>
<h2 id="15、Qt的鼠标事件"><a href="#15、Qt的鼠标事件" class="headerlink" title="15、Qt的鼠标事件"></a>15、Qt的鼠标事件</h2><blockquote>
<p>1、鼠标进入事件enterEvent</p>
<p>2、鼠标离开事件leaveEvent</p>
<p>3、鼠标移动 mouseMoveEvent</p>
<p>4、鼠标按下 mousePressEvent</p>
<p>5、鼠标释放 mouseReleaseEvent</p>
<p>6、ev-&gt;x(),ev-&gt;y()</p>
<p>7、ev-&gt;button() 可以判断所有按键，Qt::LeftButton,Qt::RightButton</p>
<p>8、ev-&gt;buttons() 判断组合按键，判断用 &amp;</p>
<p>9、格式化字符串 QString str &#x3D; QString（“%1  %2 %3 …”).arg().arg().arg()…</p>
</blockquote>
<pre><code class="hljs">#include &quot;mylabel.h&quot;
#include &lt;QDebug&gt;
#include &lt;QMouseEvent&gt;
myLabel::myLabel(QWidget *parent)
    : QLabel&#123;parent&#125;
&#123;
    //设置鼠标追踪状态,默认是false
    setMouseTracking(true);
</code></pre>
<p>​<br>​    }<br>​    void myLabel::enterEvent(QEvent *event)<br>​    {<br>​<br>​        qDebug()&lt;&lt;”鼠标进入”;<br>​    }<br>​<br>​    void myLabel::leaveEvent(QEvent *)<br>​    {<br>​        qDebug()&lt;&lt;”鼠标离开”;<br>​    }<br>​    </p>
<pre><code class="hljs">void myLabel::mouseMoveEvent(QMouseEvent *ev)//持续过程
&#123;
//    if(ev-&gt;buttons() &amp; Qt::LeftButton)//同真才为真
//    &#123;
        QString str = QString(&quot;鼠标移动了，x = %1 y = %2 globalx = %3 globaly = %4&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()).arg(ev-&gt;globalX()).arg(ev-&gt;globalY());
        qDebug()&lt;&lt;str;
//    &#125;

&#125;
void myLabel::mousePressEvent(QMouseEvent *ev)//瞬间
&#123;
//    if(ev-&gt;button() == Qt::LeftButton)//左键才打印
//    &#123;
        QString str = QString(&quot;鼠标按下了，x = %1 y = %2 globalx = %3 globaly = %4&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()).arg(ev-&gt;globalX()).arg(ev-&gt;globalY());
        qDebug()&lt;&lt;str;
//    &#125;

&#125;
void myLabel::mouseReleaseEvent(QMouseEvent *ev)//瞬间
&#123;

//    if(ev-&gt;button() == Qt::LeftButton)//左键才打印
//    &#123;
        QString str = QString(&quot;鼠标释放了，x = %1 y = %2 globalx = %3 globaly = %4&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()).arg(ev-&gt;globalX()).arg(ev-&gt;globalY());
        qDebug()&lt;&lt;str;
//    &#125;

&#125;
</code></pre>
<h2 id="16、定时器"><a href="#16、定时器" class="headerlink" title="16、定时器"></a>16、定时器</h2><blockquote>
<p>1、利用事件void timerEvent（QTimerEvent *e）</p>
<p>2、启动定时器 startTimer（1000）毫秒单位</p>
<p>3、timerEvent的返回值是定时器定时器的唯一标识，可以和 e-&gt;timerId 做比较</p>
<p>4、利用定时器类 QTimer</p>
<p>5、先创建定时器对象，启动定时器start（毫秒）</p>
<p>6、每隔一定毫秒，发送信号timeout，进行监听</p>
</blockquote>
<pre><code class="hljs">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;
#include &lt;QTimer&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    // 启动定时器 单位是毫秒
    id1 = startTimer(1000);
    id2 = startTimer(2000);

    //定时器第二种方式
    QTimer *timer = new QTimer(this);
    //启动定时器
    timer-&gt;start(500);//0.5s进入中断
    connect(timer,&amp;QTimer::timeout,[=]()&#123;
        static int num = 1;
        //每0.5s加1；
        ui-&gt;label_4-&gt;setText(QString::number(num++));
    &#125;);
    connect(ui-&gt;stop,&amp;QPushButton::clicked,[=]()&#123;
        timer-&gt;stop();
    &#125;);
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;

void Widget::timerEvent(QTimerEvent *e)
&#123;

    //label_2 每隔1s +1
    if(e-&gt;timerId()==id1)
    &#123;
        static int num1 = 1;
        ui-&gt;label_2-&gt;setText(QString::number(num1++));
    &#125;

    //label_3 每隔2s +1
    if(e-&gt;timerId()==id2)//判断定时器
    &#123;
        static int num2 = 1;
        ui-&gt;label_3-&gt;setText(QString::number(num2++));
    &#125;

&#125;
</code></pre>
<h2 id="17、event-事件分发器和事件过滤器"><a href="#17、event-事件分发器和事件过滤器" class="headerlink" title="17、event 事件分发器和事件过滤器 "></a>17、event 事件分发器和事件过滤器 </h2><blockquote>
<p>1、用于时间的分发，也可以做拦截(不建议)</p>
<p>2、bool event（QEvent *e）返回值是true代表永华处理这个事件，不向下分发 </p>
<p>3、e-&gt;type() &#x3D;&#x3D; 鼠标按下</p>
<p><img src="https://img-blog.csdnimg.cn/0b39e92349db4e7481d4e0f1a6883274.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<pre><code class="hljs">bool myLabel::event(QEvent *e)
&#123;
    if(e-&gt;type() == QEvent::MouseButtonPress)//鼠标按下，在事件event事件中做拦截操作
    &#123;
        QMouseEvent *ev = static_cast&lt;QMouseEvent*&gt;(e);//将e转换为ev类型
        QString str = QString(&quot;event中，，鼠标按下了，x = %1 y = %2 globalx = %3 globaly = %4&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()).arg(ev-&gt;globalX()).arg(ev-&gt;globalY());
        qDebug()&lt;&lt;str;
        return true;//代表用户自己处理事件，不向下分发
    &#125;
    //其他事件交给父类处理

    return QLabel::event(e);
&#125;
---------------------------------------------------------------------------------
bool Widget::eventFilter(QObject *obj,QEvent *e)
&#123;
    if(obj == ui-&gt;label)
    &#123;
        if(e-&gt;type() == QEvent::MouseButtonPress)//鼠标按下，在事件event事件中做拦截操作
        &#123;
            QMouseEvent *ev = static_cast&lt;QMouseEvent*&gt;(e);//将e转换为ev类型
            QString str = QString(&quot;事件过滤器中，，鼠标按下了，x = %1 y = %2 globalx = %3 globaly = %4&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()).arg(ev-&gt;globalX()).arg(ev-&gt;globalY());
            qDebug()&lt;&lt;str;
            return true;//代表用户自己处理事件，不向下分发
        &#125;
    &#125;
    // 其他默认处理
    return QWidget::eventFilter(obj,e);
&#125;
</code></pre>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/ad0ea8cd5b1e465aa1504df2bb775326.png" srcset="/img/loading.gif" lazyload></h2><h2 id="18、QPainter"><a href="#18、QPainter" class="headerlink" title="18、QPainter"></a>18、QPainter</h2><h3 id="18-1-绘图事件"><a href="#18-1-绘图事件" class="headerlink" title="18.1 绘图事件"></a>18.1 绘图事件</h3><blockquote>
<p>1、绘图事件 void paintEvent()</p>
<p>2、声明一个画家对象</p>
</blockquote>
<pre><code class="hljs">void Widget::paintEvent(QPaintEvent *)
&#123;
    //实例化画家对象 this指定的是绘图设备
    QPainter painter(this);
    //设置画笔
    QPen pen(QColor(255,0,0));
    //设置画笔宽度
    pen.setWidth(3);
    //设置画笔风格
    pen.setStyle(Qt::DotLine);
    //让画家使用这个笔
    painter.setPen(pen);

    //设置画刷
    QBrush brush(Qt::cyan);
    //设置画刷风格
    brush.setStyle(Qt::Dense7Pattern);
    //让画家使用画刷
    painter.setBrush(brush);
​        //划线
​        painter.drawLine(QPoint(0,0),QPoint(100,100));
​        //画圆 椭圆
​        painter.drawEllipse(QPoint(100,100),50,50);
​    &#125;
</code></pre>
<h3 id="18-2-绘图高级设置"><a href="#18-2-绘图高级设置" class="headerlink" title="18.2 绘图高级设置"></a>18.2 绘图高级设置</h3><blockquote>
<p>1、抗锯齿，效率低</p>
<p>2、对画家进行移动，保存状态，还原状态</p>
</blockquote>
<pre><code class="hljs">void Widget::paintEvent(QPaintEvent *)
&#123;
    QPainter painter(this);
    painter.drawEllipse(QPoint(100,50),50,50);
    //设置抗锯齿能力 效率低
    painter.setRenderHint(QPainter::Antialiasing);
    painter.drawEllipse(QPoint(200,50),50,50);
    //画矩形
    painter.drawRect(QRect(20,20,50,50));
    //让画家移动位置
    painter.translate(100,0);

    //保存画家状态
    painter.save();

    //画另一个矩形
    painter.drawRect(QRect(20,20,50,50));

    painter.translate(100,0);
    //还原画家状态
    painter.restore();
    painter.drawRect(QRect(20,20,50,50));
&#125;
</code></pre>
<h3 id="18-3-手动调用绘图事件"><a href="#18-3-手动调用绘图事件" class="headerlink" title="18.3 手动调用绘图事件"></a>18.3 手动调用绘图事件</h3><blockquote>
<p>如果想手动调用绘图事件，利用update，利用画家画图片painterDrawPixmap</p>
</blockquote>
<pre><code class="hljs">Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    //移动
    connect(ui-&gt;btn_move,&amp;QPushButton::clicked,[=]()&#123;

      //如果要手动调用绘图事件，用update更新
      update();
      posx += 20;

    &#125;);
&#125;
void Widget::paintEvent(QPaintEvent *)
&#123;
    QPainter painter(this);
    //如果超过屏幕，重新开始
    if(posx &gt; this-&gt;width())
    &#123;
        posx = 0;
    &#125;
    painter.drawPixmap(posx,0,QPixmap(&quot;:/Image_1/10.jpg&quot;));
&#125;
</code></pre>
<h3 id="18-4-绘图设备"><a href="#18-4-绘图设备" class="headerlink" title="18.4 绘图设备"></a>18.4 绘图设备</h3><blockquote>
<p>1. QPixmap QImage QBitmap(黑白)QPicture QWidget</p>
<p>2. QPixmap 对不同平台做了显示优化</p>
<p>3. QImage可以对像素进行访问</p>
<p>4. QPicture可以记录和重现绘图指令</p>
</blockquote>
<pre><code class="hljs">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;
#include &lt;QPixmap&gt;
#include &lt;QPainter&gt;
#include &lt;QImage&gt;
#include &lt;QPicture&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

//    //Pixmap绘图设备 专门为平台做了显示的优化
//    QPixmap pix(400,400);
//    QPainter painter(&amp;pix);
//    //填充颜色
//    pix.fill(Qt::white);
//    painter.setPen(QPen(Qt::blue));
//    painter.drawEllipse(QPoint(200,200),100,100);

//    //保存到磁盘
//    pix.save(&quot;E:\\pix.png&quot;);

    //QImage 绘图设备 可以对像素进行访问
//    QImage img(300,300,QImage::Format_RGB666);
//    img.fill(Qt::white);
//    QPainter painter(&amp;img);
//    painter.setPen(QPen(Qt::blue));
//    painter.drawEllipse(QPoint(200,200),100,100);
//    img.save(&quot;E:\\img.png&quot;);

    //QPicture 绘图设备 可以记录和重新绘图指令
    QPicture pic;
    QPainter painter;
    painter.begin(&amp;pic);//开始往pic画

    painter.setPen(QPen(Qt::cyan));
    painter.drawEllipse(QPoint(150,150),100,100);

    painter.end();//结束画图

    pic.save(&quot;E:\\pic.zt&quot;);
​    &#125;
​    void Widget::paintEvent(QPaintEvent *event)
​    &#123;
​         //利用QImage对像素点修改
​    //    QPainter painter(this);
​    //    QImage img;
​    //    img.load(&quot;:/Image_1/10.jpg&quot;);
​    
​    //    //修改像素点
​    //    for(int i = 50;i&lt;100;i++)
​    //    &#123;
​    //        for(int j = 50; j&lt;100;j++)
​    //        &#123;
​    //            QRgb value = qRgb(255,0,0);
​    //            img.setPixel(i,j,value);
​    //        &#125;
​    //    &#125;
​    //    painter.drawImage(0,0,img);
​    
        //重现QPicture的绘图指令
         QPainter painter(this);
         QPicture pic;
         pic.load(&quot;E:\\pic.zt&quot;);
         painter.drawPicture(0,0,pic);
    &#125;
</code></pre>
<h2 id="19、QFile文件读写操作"><a href="#19、QFile文件读写操作" class="headerlink" title="19、QFile文件读写操作"></a>19、QFile文件读写操作</h2><h3 id="文件QFile和文件信息读写QFileInfo"><a href="#文件QFile和文件信息读写QFileInfo" class="headerlink" title="文件QFile和文件信息读写QFileInfo"></a>文件QFile和文件信息读写QFileInfo</h3><blockquote>
<p><img src="https://img-blog.csdnimg.cn/c05ec249778e4864adf7014d74cdaa2c.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<pre><code class="hljs">Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);
    //点击选取文件按钮，弹出文件对话框
    connect(ui-&gt;btn_file,&amp;QPushButton::clicked,[=]()
            &#123;
                QString path = QFileDialog::getOpenFileName(this,&quot;打开文件&quot;,&quot;E:\\1.Qt_temporary_files&quot;);
                //将路径放入到lineEdit
                ui-&gt;lineEdit-&gt;setText(path);

                //编码格式类
                //QTextCodec *codec = QTextCodec::codecForName(&quot;gbk&quot;);

                //读取内容，放入textEdit中
                QFile file(path);//参数就是读取文件的路径
                //设置打开方式
                file.open(QIODevice::ReadOnly);

                //QByteArray array = file.readAll();

                //按行读取
                QByteArray array;
                while(!file.atEnd())
                &#123;
                    array += file.readLine();
                &#125; 
                //将读入的数据放入textEdit
                ui-&gt;textEdit-&gt;setText(array);

                //转成gbk格式，默认是utf-8格式
              //ui-&gt;textEdit-&gt;setText(codec-&gt;toUnicode(array));
   
                //对文件对象进行关闭
                file.close();
                //进行写文件
//                file.open(QIODevice::Append);//用追加的方式进行写
//                file.write(&quot;aaaaaa&quot;);
//                file.close();

                //QFileInfo读取文件信息
                QFileInfo info(path);

                qDebug()&lt;&lt;&quot;大小：&quot;&lt;&lt;info.size()&lt;&lt;&quot;后缀名：&quot;&lt;&lt;info.suffix()&lt;&lt;&quot;文件名：&quot;&lt;&lt;info.fileName();
                qDebug()&lt;&lt;&quot;创建日期：&quot;&lt;&lt;info.birthTime().toString(&quot;yyyy/MM/dd hh:mm:ss&quot;);
            &#125;);
&#125;
</code></pre>
<h2 id="20、翻金币项目"><a href="#20、翻金币项目" class="headerlink" title="20、翻金币项目 "></a>20、翻金币项目 </h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/q5120192609/article/details/127470422">https://blog.csdn.net/q5120192609/article/details/127470422</a></p>
<p>转载就当作是自己的（</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Qt/" class="print-no-link">#Qt</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Qt学习笔记</div>
      <div>http://example.com/2023/11/20/Qt学习笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>hhy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/09/07/Pytorch-tudui/" title="Pytorch_tudui">
                        <span class="hidden-mobile">Pytorch_tudui</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>
<div>
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
  var now = new Date();
  function createtime(){
      var grt= new Date("08/06/2023 12:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "🚀 for&nbsp"+dnum+"&nbspdays";  //此次自定义显示内容
      document.getElementById("times").innerHTML = hnum + "&nbsphr&nbsp" + mnum + "&nbspmin&nbsp" + snum + "&nbspsec";
  }  //此次自定义显示内容
  setInterval("createtime()",250);
  </script>
</div>
  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
